ARM GAS  /tmp/ccuGp9km.s 			page 1


   1              		.cpu cortex-m7
   2              		.eabi_attribute 28, 1
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 1
  11              		.eabi_attribute 18, 4
  12              		.file	"stm32h7xx_hal_pwr.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.section	.text.HAL_PWR_DeInit,"ax",%progbits
  17              		.align	1
  18              		.global	HAL_PWR_DeInit
  19              		.arch armv7e-m
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv5-d16
  25              	HAL_PWR_DeInit:
  26              	.LFB134:
  27              		.file 1 "./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c"
   1:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
   2:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   ******************************************************************************
   3:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @file    stm32h7xx_hal_pwr.c
   4:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @author  MCD Application Team
   5:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief   PWR HAL module driver.
   6:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          This file provides firmware functions to manage the following
   7:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   8:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *           + Initialization and de-initialization functions
   9:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *           + Peripheral Control functions
  10:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *
  11:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   ******************************************************************************
  12:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @attention
  13:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *
  14:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics.
  15:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * All rights reserved.</center></h2>
  16:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *
  17:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * This software component is licensed by ST under BSD 3-Clause license,
  18:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * the "License"; You may not use this file except in compliance with the
  19:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * License. You may obtain a copy of the License at:
  20:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *                        opensource.org/licenses/BSD-3-Clause
  21:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *
  22:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   ******************************************************************************
  23:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  24:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  25:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /* Includes ------------------------------------------------------------------*/
  26:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #include "stm32h7xx_hal.h"
  27:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  28:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /** @addtogroup STM32H7xx_HAL_Driver
  29:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @{
  30:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  31:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
ARM GAS  /tmp/ccuGp9km.s 			page 2


  32:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /** @defgroup PWR PWR
  33:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief PWR HAL module driver
  34:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @{
  35:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  36:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  37:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #ifdef HAL_PWR_MODULE_ENABLED
  38:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  39:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  40:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /* Private define ------------------------------------------------------------*/
  41:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /** @addtogroup PWR_Private_Constants PWR Private Constants
  42:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @{
  43:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  44:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  45:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
  46:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @{
  47:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  48:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #if !defined (DUAL_CORE)
  49:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #define PVD_MODE_IT              ((uint32_t)0x00010000U)
  50:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #define PVD_MODE_EVT             ((uint32_t)0x00020000U)
  51:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #endif /* DUAL_CORE */
  52:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #define PVD_RISING_EDGE          ((uint32_t)0x00000001U)
  53:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #define PVD_FALLING_EDGE         ((uint32_t)0x00000002U)
  54:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #define PVD_RISING_FALLING_EDGE  ((uint32_t)0x00000003U)
  55:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
  56:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @}
  57:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  58:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  59:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
  60:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @}
  61:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  62:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /* Private macro -------------------------------------------------------------*/
  63:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /* Private variables ---------------------------------------------------------*/
  64:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /* Private function prototypes -----------------------------------------------*/
  65:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /* Private functions ---------------------------------------------------------*/
  66:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  67:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions PWR Exported Functions
  68:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @{
  69:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  70:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  71:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group1 Initialization and De-Initialization functions
  72:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *  @brief    Initialization and De-Initialization functions
  73:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *
  74:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** @verbatim
  75:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****  ===============================================================================
  76:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****               ##### Initialization and De-Initialization functions #####
  77:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****  ===============================================================================
  78:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
  79:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data
  80:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       registers and backup SRAM) is protected against possible unwanted
  81:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       write accesses.
  82:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
  83:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
  84:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****             __HAL_RCC_PWR_CLK_ENABLE() macro.
  85:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
  86:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  87:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** @endverbatim
  88:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @{
ARM GAS  /tmp/ccuGp9km.s 			page 3


  89:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  90:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
  91:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
  92:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Deinitialize the HAL PWR peripheral registers to their default reset values.
  93:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   This functionality is not available in this product.
  94:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         The prototype is kept just to maintain compatibility with other products.
  95:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
  96:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
  97:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_DeInit(void)
  98:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
  28              		.loc 1 98 1
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33 0000 80B4     		push	{r7}
  34              		.cfi_def_cfa_offset 4
  35              		.cfi_offset 7, -4
  36 0002 00AF     		add	r7, sp, #0
  37              		.cfi_def_cfa_register 7
  99:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
  38              		.loc 1 99 1
  39 0004 00BF     		nop
  40 0006 BD46     		mov	sp, r7
  41              		.cfi_def_cfa_register 13
  42              		@ sp needed
  43 0008 5DF8047B 		ldr	r7, [sp], #4
  44              		.cfi_restore 7
  45              		.cfi_def_cfa_offset 0
  46 000c 7047     		bx	lr
  47              		.cfi_endproc
  48              	.LFE134:
  50              		.section	.text.HAL_PWR_EnableBkUpAccess,"ax",%progbits
  51              		.align	1
  52              		.global	HAL_PWR_EnableBkUpAccess
  53              		.syntax unified
  54              		.thumb
  55              		.thumb_func
  56              		.fpu fpv5-d16
  58              	HAL_PWR_EnableBkUpAccess:
  59              	.LFB135:
 100:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 101:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 102:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Enable access to the backup domain (RTC registers, RTC
 103:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         backup data registers and backup SRAM).
 104:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
 105:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 106:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 107:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 108:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_EnableBkUpAccess(void)
 109:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
  60              		.loc 1 109 1
  61              		.cfi_startproc
  62              		@ args = 0, pretend = 0, frame = 0
  63              		@ frame_needed = 1, uses_anonymous_args = 0
  64              		@ link register save eliminated.
  65 0000 80B4     		push	{r7}
ARM GAS  /tmp/ccuGp9km.s 			page 4


  66              		.cfi_def_cfa_offset 4
  67              		.cfi_offset 7, -4
  68 0002 00AF     		add	r7, sp, #0
  69              		.cfi_def_cfa_register 7
 110:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Enable access to RTC and backup registers */
 111:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(PWR->CR1, PWR_CR1_DBP);
  70              		.loc 1 111 3
  71 0004 054B     		ldr	r3, .L3
  72 0006 1B68     		ldr	r3, [r3]
  73 0008 044A     		ldr	r2, .L3
  74 000a 43F48073 		orr	r3, r3, #256
  75 000e 1360     		str	r3, [r2]
 112:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
  76              		.loc 1 112 1
  77 0010 00BF     		nop
  78 0012 BD46     		mov	sp, r7
  79              		.cfi_def_cfa_register 13
  80              		@ sp needed
  81 0014 5DF8047B 		ldr	r7, [sp], #4
  82              		.cfi_restore 7
  83              		.cfi_def_cfa_offset 0
  84 0018 7047     		bx	lr
  85              	.L4:
  86 001a 00BF     		.align	2
  87              	.L3:
  88 001c 00480258 		.word	1476544512
  89              		.cfi_endproc
  90              	.LFE135:
  92              		.section	.text.HAL_PWR_DisableBkUpAccess,"ax",%progbits
  93              		.align	1
  94              		.global	HAL_PWR_DisableBkUpAccess
  95              		.syntax unified
  96              		.thumb
  97              		.thumb_func
  98              		.fpu fpv5-d16
 100              	HAL_PWR_DisableBkUpAccess:
 101              	.LFB136:
 113:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 114:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 115:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Disable access to the backup domain (RTC registers, RTC
 116:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         backup data registers and backup SRAM).
 117:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
 118:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 119:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 120:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 121:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_DisableBkUpAccess(void)
 122:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 102              		.loc 1 122 1
 103              		.cfi_startproc
 104              		@ args = 0, pretend = 0, frame = 0
 105              		@ frame_needed = 1, uses_anonymous_args = 0
 106              		@ link register save eliminated.
 107 0000 80B4     		push	{r7}
 108              		.cfi_def_cfa_offset 4
 109              		.cfi_offset 7, -4
 110 0002 00AF     		add	r7, sp, #0
 111              		.cfi_def_cfa_register 7
ARM GAS  /tmp/ccuGp9km.s 			page 5


 123:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Disable access to RTC and backup registers */
 124:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);
 112              		.loc 1 124 3
 113 0004 054B     		ldr	r3, .L6
 114 0006 1B68     		ldr	r3, [r3]
 115 0008 044A     		ldr	r2, .L6
 116 000a 23F48073 		bic	r3, r3, #256
 117 000e 1360     		str	r3, [r2]
 125:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 118              		.loc 1 125 1
 119 0010 00BF     		nop
 120 0012 BD46     		mov	sp, r7
 121              		.cfi_def_cfa_register 13
 122              		@ sp needed
 123 0014 5DF8047B 		ldr	r7, [sp], #4
 124              		.cfi_restore 7
 125              		.cfi_def_cfa_offset 0
 126 0018 7047     		bx	lr
 127              	.L7:
 128 001a 00BF     		.align	2
 129              	.L6:
 130 001c 00480258 		.word	1476544512
 131              		.cfi_endproc
 132              	.LFE136:
 134              		.section	.text.HAL_PWR_ConfigPVD,"ax",%progbits
 135              		.align	1
 136              		.global	HAL_PWR_ConfigPVD
 137              		.syntax unified
 138              		.thumb
 139              		.thumb_func
 140              		.fpu fpv5-d16
 142              	HAL_PWR_ConfigPVD:
 143              	.LFB137:
 126:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 127:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 128:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @}
 129:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 130:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 131:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions
 132:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *  @brief   Low Power modes configuration functions
 133:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *
 134:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** @verbatim
 135:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 136:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****  ===============================================================================
 137:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****                  ##### Peripheral Control functions #####
 138:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****  ===============================================================================
 139:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 140:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     *** PVD configuration ***
 141:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     =========================
 142:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
 143:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a
 144:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           threshold selected by the PVD Level (PLS[7:0] bits in the PWR_CR1 register).
 145:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) A PVDO flag is available to indicate if VDD is higher or lower
 146:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI
 147:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           line 16 to generate an interrupt if enabled.
 148:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           It is configurable through __HAL_PWR_PVD_EXTI_ENABLE_IT() macro.
 149:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) The PVD is stopped in Standby mode.
ARM GAS  /tmp/ccuGp9km.s 			page 6


 150:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 151:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     *** Wake-up pin configuration ***
 152:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     ================================
 153:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
 154:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) Wake-up pin is used to wake up the system from Standby mode.
 155:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           The pin pull is configurable through the WKUPEPR register to be in No pull-up, Pull-up an
 156:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           The pin polarity is configurable through the WKUPEPR register to be active on rising or f
 157:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) There are up to six Wake-up pin in the STM32H7 devices family.
 158:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 159:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     *** Low Power modes configuration ***
 160:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     =====================================
 161:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
 162:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****      The device present 3 principles low-power modes features:
 163:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) SLEEP mode: Cortex-M7 core stopped and D1, D2 and D3 peripherals kept running.
 164:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) STOP mode: all clocks are stopped and the regulator is running in main or low power mode.
 165:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) STANDBY mode: D1, D2 and D3 domains enter DSTANDBY mode and the VCORE supply
 166:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****                         regulator is powered off.
 167:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 168:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****    *** SLEEP mode ***
 169:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****    ==================
 170:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
 171:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) Entry:
 172:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(Regulator, SLEEPEntry)
 173:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         function.
 174:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 175:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 176:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 177:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 178:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       -@@- The Regulator parameter is not used for the STM32H7 family
 179:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****               and is kept as parameter just to maintain compatibility with the
 180:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****               lower power families (STM32L).
 181:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) Exit:
 182:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         Any peripheral interrupt acknowledged by the nested vectored interrupt
 183:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         controller (NVIC) can wake up the device from Sleep mode.
 184:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 185:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****    *** STOP mode ***
 186:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****    =================
 187:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
 188:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       In system Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
 189:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       and the HSE RC oscillators are disabled. Internal SRAM and register contents
 190:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       are preserved.
 191:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       The voltage regulator can be configured either in normal or low-power mode.
 192:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       To minimize the consumption In Stop mode, FLASH can be powered off before
 193:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       entering the Stop mode using the HAL_PWREx_EnableFlashPowerDown() function.
 194:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       It can be switched on again by software after exiting the Stop mode using
 195:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       the HAL_PWREx_DisableFlashPowerDown() function.
 196:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 197:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) Entry:
 198:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****          The Stop mode is entered using the HAL_PWR_EnterSTOPMode(Regulator, STOPEntry)
 199:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****          function with:
 200:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****          (++) Regulator:
 201:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           (+++) PWR_MAINREGULATOR_ON: Main regulator ON.
 202:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           (+++) PWR_LOWPOWERREGULATOR_ON: Low Power regulator ON.
 203:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****          (++) STOPEntry:
 204:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           (+++) PWR_STOPENTRY_WFI: enter STOP mode with WFI instruction
 205:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****           (+++) PWR_STOPENTRY_WFE: enter STOP mode with WFE instruction
 206:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (+) Exit:
ARM GAS  /tmp/ccuGp9km.s 			page 7


 207:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
 208:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 209:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****    *** STANDBY mode ***
 210:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****    ====================
 211:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
 212:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     (+)
 213:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       The system Standby mode allows to achieve the lowest power consumption. It is based
 214:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       on the Cortex-M7 deep sleep mode, with the voltage regulator disabled.
 215:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       The system is consequently powered off. The PLL, the HSI oscillator and
 216:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       the HSE oscillator are also switched off. SRAM and register contents are lost
 217:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       except for the RTC registers, RTC backup registers, backup SRAM and Standby
 218:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       circuitry.
 219:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
 220:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       The voltage regulator is OFF.
 221:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (++) Entry:
 222:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         (+++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
 223:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       (++) Exit:
 224:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****         (+++) WKUP pin rising or falling edge, RTC alarm (Alarm A and Alarm B), RTC
 225:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****               wakeup, tamper event, time stamp event, external reset in NRST pin, IWDG reset.
 226:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 227:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 228:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****    =============================================
 229:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     [..]
 230:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****      (+) The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC
 231:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       Wakeup event, a tamper event or a time-stamp event, without depending on
 232:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       an external interrupt (Auto-wakeup mode).
 233:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****      (+) RTC auto-wakeup (AWU) from the STOP and STANDBY modes
 234:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****        (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to
 235:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****             configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.
 236:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****        (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it
 237:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****             is necessary to configure the RTC to detect the tamper or time stamp event using the
 238:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****             HAL_RTCEx_SetTimeStamp_IT() or HAL_RTCEx_SetTamper_IT() functions.
 239:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****        (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to
 240:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****             configure the RTC to generate the RTC WakeUp event using the HAL_RTCEx_SetWakeUpTimer_I
 241:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 242:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** @endverbatim
 243:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @{
 244:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 245:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 246:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 247:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Configure the voltage threshold detected by the Power Voltage Detector(PVD).
 248:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @param  sConfigPVD: pointer to an PWR_PVDTypeDef structure that contains the configuration
 249:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         information for the PVD.
 250:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 251:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         more details about the voltage threshold corresponding to each
 252:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         detection level.
 253:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 254:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 255:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
 256:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 144              		.loc 1 256 1
 145              		.cfi_startproc
 146              		@ args = 0, pretend = 0, frame = 8
 147              		@ frame_needed = 1, uses_anonymous_args = 0
 148              		@ link register save eliminated.
 149 0000 80B4     		push	{r7}
 150              		.cfi_def_cfa_offset 4
ARM GAS  /tmp/ccuGp9km.s 			page 8


 151              		.cfi_offset 7, -4
 152 0002 83B0     		sub	sp, sp, #12
 153              		.cfi_def_cfa_offset 16
 154 0004 00AF     		add	r7, sp, #0
 155              		.cfi_def_cfa_register 7
 156 0006 7860     		str	r0, [r7, #4]
 257:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Check the parameters */
 258:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
 259:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
 260:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 261:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Set PLS[7:5] bits according to PVDLevel value */
 262:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   MODIFY_REG(PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
 157              		.loc 1 262 3
 158 0008 374B     		ldr	r3, .L14
 159 000a 1B68     		ldr	r3, [r3]
 160 000c 23F0E002 		bic	r2, r3, #224
 161 0010 7B68     		ldr	r3, [r7, #4]
 162 0012 1B68     		ldr	r3, [r3]
 163 0014 3449     		ldr	r1, .L14
 164 0016 1343     		orrs	r3, r3, r2
 165 0018 0B60     		str	r3, [r1]
 263:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 264:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Clear any previous config */
 265:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #if !defined (DUAL_CORE)
 266:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 166              		.loc 1 266 3
 167 001a 4FF0B043 		mov	r3, #1476395008
 168 001e D3F88430 		ldr	r3, [r3, #132]
 169 0022 4FF0B042 		mov	r2, #1476395008
 170 0026 23F48033 		bic	r3, r3, #65536
 171 002a C2F88430 		str	r3, [r2, #132]
 267:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_IT();
 172              		.loc 1 267 3
 173 002e 4FF0B043 		mov	r3, #1476395008
 174 0032 D3F88030 		ldr	r3, [r3, #128]
 175 0036 4FF0B042 		mov	r2, #1476395008
 176 003a 23F48033 		bic	r3, r3, #65536
 177 003e C2F88030 		str	r3, [r2, #128]
 268:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #endif /* DUAL_CORE */
 269:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 178              		.loc 1 269 3
 179 0042 4FF0B043 		mov	r3, #1476395008
 180 0046 1B68     		ldr	r3, [r3]
 181 0048 4FF0B042 		mov	r2, #1476395008
 182 004c 23F48033 		bic	r3, r3, #65536
 183 0050 1360     		str	r3, [r2]
 270:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();
 184              		.loc 1 270 3
 185 0052 4FF0B043 		mov	r3, #1476395008
 186 0056 5B68     		ldr	r3, [r3, #4]
 187 0058 4FF0B042 		mov	r2, #1476395008
 188 005c 23F48033 		bic	r3, r3, #65536
 189 0060 5360     		str	r3, [r2, #4]
 271:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 272:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #if !defined (DUAL_CORE)
 273:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Configure interrupt mode */
 274:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
ARM GAS  /tmp/ccuGp9km.s 			page 9


 190              		.loc 1 274 17
 191 0062 7B68     		ldr	r3, [r7, #4]
 192 0064 5B68     		ldr	r3, [r3, #4]
 193              		.loc 1 274 24
 194 0066 03F48033 		and	r3, r3, #65536
 195              		.loc 1 274 5
 196 006a 002B     		cmp	r3, #0
 197 006c 09D0     		beq	.L9
 275:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 276:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_IT();
 198              		.loc 1 276 5
 199 006e 4FF0B043 		mov	r3, #1476395008
 200 0072 D3F88030 		ldr	r3, [r3, #128]
 201 0076 4FF0B042 		mov	r2, #1476395008
 202 007a 43F48033 		orr	r3, r3, #65536
 203 007e C2F88030 		str	r3, [r2, #128]
 204              	.L9:
 277:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 278:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 279:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Configure event mode */
 280:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 205              		.loc 1 280 17
 206 0082 7B68     		ldr	r3, [r7, #4]
 207 0084 5B68     		ldr	r3, [r3, #4]
 208              		.loc 1 280 24
 209 0086 03F40033 		and	r3, r3, #131072
 210              		.loc 1 280 5
 211 008a 002B     		cmp	r3, #0
 212 008c 09D0     		beq	.L10
 281:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 282:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 213              		.loc 1 282 5
 214 008e 4FF0B043 		mov	r3, #1476395008
 215 0092 D3F88430 		ldr	r3, [r3, #132]
 216 0096 4FF0B042 		mov	r2, #1476395008
 217 009a 43F48033 		orr	r3, r3, #65536
 218 009e C2F88430 		str	r3, [r2, #132]
 219              	.L10:
 283:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 284:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #endif /* DUAL_CORE */
 285:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 286:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Configure the edge */
 287:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 220              		.loc 1 287 17
 221 00a2 7B68     		ldr	r3, [r7, #4]
 222 00a4 5B68     		ldr	r3, [r3, #4]
 223              		.loc 1 287 24
 224 00a6 03F00103 		and	r3, r3, #1
 225              		.loc 1 287 5
 226 00aa 002B     		cmp	r3, #0
 227 00ac 07D0     		beq	.L11
 288:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 289:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 228              		.loc 1 289 5
 229 00ae 4FF0B043 		mov	r3, #1476395008
 230 00b2 1B68     		ldr	r3, [r3]
 231 00b4 4FF0B042 		mov	r2, #1476395008
ARM GAS  /tmp/ccuGp9km.s 			page 10


 232 00b8 43F48033 		orr	r3, r3, #65536
 233 00bc 1360     		str	r3, [r2]
 234              	.L11:
 290:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 291:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 292:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 235              		.loc 1 292 17
 236 00be 7B68     		ldr	r3, [r7, #4]
 237 00c0 5B68     		ldr	r3, [r3, #4]
 238              		.loc 1 292 24
 239 00c2 03F00203 		and	r3, r3, #2
 240              		.loc 1 292 5
 241 00c6 002B     		cmp	r3, #0
 242 00c8 07D0     		beq	.L13
 293:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 294:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 243              		.loc 1 294 5
 244 00ca 4FF0B043 		mov	r3, #1476395008
 245 00ce 5B68     		ldr	r3, [r3, #4]
 246 00d0 4FF0B042 		mov	r2, #1476395008
 247 00d4 43F48033 		orr	r3, r3, #65536
 248 00d8 5360     		str	r3, [r2, #4]
 249              	.L13:
 295:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 296:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 250              		.loc 1 296 1
 251 00da 00BF     		nop
 252 00dc 0C37     		adds	r7, r7, #12
 253              		.cfi_def_cfa_offset 4
 254 00de BD46     		mov	sp, r7
 255              		.cfi_def_cfa_register 13
 256              		@ sp needed
 257 00e0 5DF8047B 		ldr	r7, [sp], #4
 258              		.cfi_restore 7
 259              		.cfi_def_cfa_offset 0
 260 00e4 7047     		bx	lr
 261              	.L15:
 262 00e6 00BF     		.align	2
 263              	.L14:
 264 00e8 00480258 		.word	1476544512
 265              		.cfi_endproc
 266              	.LFE137:
 268              		.section	.text.HAL_PWR_EnablePVD,"ax",%progbits
 269              		.align	1
 270              		.global	HAL_PWR_EnablePVD
 271              		.syntax unified
 272              		.thumb
 273              		.thumb_func
 274              		.fpu fpv5-d16
 276              	HAL_PWR_EnablePVD:
 277              	.LFB138:
 297:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 298:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 299:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Enable the Power Voltage Detector(PVD).
 300:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 301:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 302:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_EnablePVD(void)
ARM GAS  /tmp/ccuGp9km.s 			page 11


 303:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 278              		.loc 1 303 1
 279              		.cfi_startproc
 280              		@ args = 0, pretend = 0, frame = 0
 281              		@ frame_needed = 1, uses_anonymous_args = 0
 282              		@ link register save eliminated.
 283 0000 80B4     		push	{r7}
 284              		.cfi_def_cfa_offset 4
 285              		.cfi_offset 7, -4
 286 0002 00AF     		add	r7, sp, #0
 287              		.cfi_def_cfa_register 7
 304:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Enable the power voltage detector */
 305:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(PWR->CR1, PWR_CR1_PVDEN);
 288              		.loc 1 305 3
 289 0004 054B     		ldr	r3, .L17
 290 0006 1B68     		ldr	r3, [r3]
 291 0008 044A     		ldr	r2, .L17
 292 000a 43F01003 		orr	r3, r3, #16
 293 000e 1360     		str	r3, [r2]
 306:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 294              		.loc 1 306 1
 295 0010 00BF     		nop
 296 0012 BD46     		mov	sp, r7
 297              		.cfi_def_cfa_register 13
 298              		@ sp needed
 299 0014 5DF8047B 		ldr	r7, [sp], #4
 300              		.cfi_restore 7
 301              		.cfi_def_cfa_offset 0
 302 0018 7047     		bx	lr
 303              	.L18:
 304 001a 00BF     		.align	2
 305              	.L17:
 306 001c 00480258 		.word	1476544512
 307              		.cfi_endproc
 308              	.LFE138:
 310              		.section	.text.HAL_PWR_DisablePVD,"ax",%progbits
 311              		.align	1
 312              		.global	HAL_PWR_DisablePVD
 313              		.syntax unified
 314              		.thumb
 315              		.thumb_func
 316              		.fpu fpv5-d16
 318              	HAL_PWR_DisablePVD:
 319              	.LFB139:
 307:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 308:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 309:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Disable the Power Voltage Detector(PVD).
 310:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 311:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 312:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_DisablePVD(void)
 313:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 320              		.loc 1 313 1
 321              		.cfi_startproc
 322              		@ args = 0, pretend = 0, frame = 0
 323              		@ frame_needed = 1, uses_anonymous_args = 0
 324              		@ link register save eliminated.
 325 0000 80B4     		push	{r7}
ARM GAS  /tmp/ccuGp9km.s 			page 12


 326              		.cfi_def_cfa_offset 4
 327              		.cfi_offset 7, -4
 328 0002 00AF     		add	r7, sp, #0
 329              		.cfi_def_cfa_register 7
 314:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Disable the power voltage detector */
 315:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR1, PWR_CR1_PVDEN);
 330              		.loc 1 315 3
 331 0004 054B     		ldr	r3, .L20
 332 0006 1B68     		ldr	r3, [r3]
 333 0008 044A     		ldr	r2, .L20
 334 000a 23F01003 		bic	r3, r3, #16
 335 000e 1360     		str	r3, [r2]
 316:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 336              		.loc 1 316 1
 337 0010 00BF     		nop
 338 0012 BD46     		mov	sp, r7
 339              		.cfi_def_cfa_register 13
 340              		@ sp needed
 341 0014 5DF8047B 		ldr	r7, [sp], #4
 342              		.cfi_restore 7
 343              		.cfi_def_cfa_offset 0
 344 0018 7047     		bx	lr
 345              	.L21:
 346 001a 00BF     		.align	2
 347              	.L20:
 348 001c 00480258 		.word	1476544512
 349              		.cfi_endproc
 350              	.LFE139:
 352              		.section	.text.HAL_PWR_EnableWakeUpPin,"ax",%progbits
 353              		.align	1
 354              		.global	HAL_PWR_EnableWakeUpPin
 355              		.syntax unified
 356              		.thumb
 357              		.thumb_func
 358              		.fpu fpv5-d16
 360              	HAL_PWR_EnableWakeUpPin:
 361              	.LFB140:
 317:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 318:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 319:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Enable the WakeUp PINx functionality.
 320:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @param  WakeUpPinPolarity: Specifies which Wake-Up pin to enable.
 321:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          This parameter can be one of the following legacy values, which sets the default:
 322:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          polarity detection on high level (rising edge):
 323:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN1, PWR_WAKEUP_PIN2, PWR_WAKEUP_PIN3, PWR_WAKEUP_PIN4,
 324:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *                 PWR_WAKEUP_PIN5, PWR_WAKEUP_PIN6 or one of the following values where
 325:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *                 the user can explicitly states the enabled pin and the chosen polarity.
 326:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN1_HIGH or PWR_WAKEUP_PIN1_LOW
 327:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN2_HIGH or PWR_WAKEUP_PIN2_LOW
 328:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN3_HIGH or PWR_WAKEUP_PIN3_LOW
 329:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN4_HIGH or PWR_WAKEUP_PIN4_LOW
 330:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN5_HIGH or PWR_WAKEUP_PIN5_LOW
 331:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN6_HIGH or PWR_WAKEUP_PIN6_LOW
 332:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.
 333:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 334:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 335:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinPolarity)
 336:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
ARM GAS  /tmp/ccuGp9km.s 			page 13


 362              		.loc 1 336 1
 363              		.cfi_startproc
 364              		@ args = 0, pretend = 0, frame = 8
 365              		@ frame_needed = 1, uses_anonymous_args = 0
 366              		@ link register save eliminated.
 367 0000 80B4     		push	{r7}
 368              		.cfi_def_cfa_offset 4
 369              		.cfi_offset 7, -4
 370 0002 83B0     		sub	sp, sp, #12
 371              		.cfi_def_cfa_offset 16
 372 0004 00AF     		add	r7, sp, #0
 373              		.cfi_def_cfa_register 7
 374 0006 7860     		str	r0, [r7, #4]
 337:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinPolarity));
 338:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 339:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Enable and Specify the Wake-Up pin polarity and the pull configuration
 340:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****      for the event detection (rising or falling edge) */
 341:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   MODIFY_REG(PWR->WKUPEPR, PWR_EWUP_MASK, WakeUpPinPolarity);
 375              		.loc 1 341 3
 376 0008 064B     		ldr	r3, .L23
 377 000a 9A6A     		ldr	r2, [r3, #40]
 378 000c 064B     		ldr	r3, .L23+4
 379 000e 1340     		ands	r3, r3, r2
 380 0010 0449     		ldr	r1, .L23
 381 0012 7A68     		ldr	r2, [r7, #4]
 382 0014 1343     		orrs	r3, r3, r2
 383 0016 8B62     		str	r3, [r1, #40]
 342:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 384              		.loc 1 342 1
 385 0018 00BF     		nop
 386 001a 0C37     		adds	r7, r7, #12
 387              		.cfi_def_cfa_offset 4
 388 001c BD46     		mov	sp, r7
 389              		.cfi_def_cfa_register 13
 390              		@ sp needed
 391 001e 5DF8047B 		ldr	r7, [sp], #4
 392              		.cfi_restore 7
 393              		.cfi_def_cfa_offset 0
 394 0022 7047     		bx	lr
 395              	.L24:
 396              		.align	2
 397              	.L23:
 398 0024 00480258 		.word	1476544512
 399 0028 C0C000F0 		.word	-268386112
 400              		.cfi_endproc
 401              	.LFE140:
 403              		.section	.text.HAL_PWR_DisableWakeUpPin,"ax",%progbits
 404              		.align	1
 405              		.global	HAL_PWR_DisableWakeUpPin
 406              		.syntax unified
 407              		.thumb
 408              		.thumb_func
 409              		.fpu fpv5-d16
 411              	HAL_PWR_DisableWakeUpPin:
 412              	.LFB141:
 343:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 344:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
ARM GAS  /tmp/ccuGp9km.s 			page 14


 345:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Disable the WakeUp PINx functionality.
 346:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @param  WakeUpPinx: Specifies the Power Wake-Up pin to disable.
 347:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 348:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN1
 349:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN2
 350:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN3
 351:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN4
 352:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN5
 353:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_WAKEUP_PIN6
 354:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 355:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 356:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
 357:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 413              		.loc 1 357 1
 414              		.cfi_startproc
 415              		@ args = 0, pretend = 0, frame = 8
 416              		@ frame_needed = 1, uses_anonymous_args = 0
 417              		@ link register save eliminated.
 418 0000 80B4     		push	{r7}
 419              		.cfi_def_cfa_offset 4
 420              		.cfi_offset 7, -4
 421 0002 83B0     		sub	sp, sp, #12
 422              		.cfi_def_cfa_offset 16
 423 0004 00AF     		add	r7, sp, #0
 424              		.cfi_def_cfa_register 7
 425 0006 7860     		str	r0, [r7, #4]
 358:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 359:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 360:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(PWR->WKUPEPR, (PWR_WKUPEPR_WKUPEN & WakeUpPinx));
 426              		.loc 1 360 3
 427 0008 074B     		ldr	r3, .L26
 428 000a 9A6A     		ldr	r2, [r3, #40]
 429 000c 7B68     		ldr	r3, [r7, #4]
 430 000e 03F03F03 		and	r3, r3, #63
 431 0012 DB43     		mvns	r3, r3
 432 0014 0449     		ldr	r1, .L26
 433 0016 1340     		ands	r3, r3, r2
 434 0018 8B62     		str	r3, [r1, #40]
 361:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 435              		.loc 1 361 1
 436 001a 00BF     		nop
 437 001c 0C37     		adds	r7, r7, #12
 438              		.cfi_def_cfa_offset 4
 439 001e BD46     		mov	sp, r7
 440              		.cfi_def_cfa_register 13
 441              		@ sp needed
 442 0020 5DF8047B 		ldr	r7, [sp], #4
 443              		.cfi_restore 7
 444              		.cfi_def_cfa_offset 0
 445 0024 7047     		bx	lr
 446              	.L27:
 447 0026 00BF     		.align	2
 448              	.L26:
 449 0028 00480258 		.word	1476544512
 450              		.cfi_endproc
 451              	.LFE141:
 453              		.section	.text.HAL_PWR_EnterSLEEPMode,"ax",%progbits
ARM GAS  /tmp/ccuGp9km.s 			page 15


 454              		.align	1
 455              		.global	HAL_PWR_EnterSLEEPMode
 456              		.syntax unified
 457              		.thumb
 458              		.thumb_func
 459              		.fpu fpv5-d16
 461              	HAL_PWR_EnterSLEEPMode:
 462              	.LFB142:
 362:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 363:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 364:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Enter the current core to Sleep mode.
 365:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @param  Regulator: Specifies the regulator state in SLEEP mode.
 366:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 367:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON
 368:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON
 369:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   This parameter is not used for the STM32H7 family and is kept as parameter
 370:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         just to maintain compatibility with the lower power families.
 371:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @param  SLEEPEntry: Specifies if SLEEP mode in entered with WFI or WFE instruction.
 372:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 373:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 374:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 375:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 376:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 377:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
 378:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 463              		.loc 1 378 1
 464              		.cfi_startproc
 465              		@ args = 0, pretend = 0, frame = 8
 466              		@ frame_needed = 1, uses_anonymous_args = 0
 467              		@ link register save eliminated.
 468 0000 80B4     		push	{r7}
 469              		.cfi_def_cfa_offset 4
 470              		.cfi_offset 7, -4
 471 0002 83B0     		sub	sp, sp, #12
 472              		.cfi_def_cfa_offset 16
 473 0004 00AF     		add	r7, sp, #0
 474              		.cfi_def_cfa_register 7
 475 0006 7860     		str	r0, [r7, #4]
 476 0008 0B46     		mov	r3, r1
 477 000a FB70     		strb	r3, [r7, #3]
 379:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Check the parameters */
 380:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 381:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
 382:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 383:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 384:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 478              		.loc 1 384 3
 479 000c 084B     		ldr	r3, .L32
 480 000e 1B69     		ldr	r3, [r3, #16]
 481 0010 074A     		ldr	r2, .L32
 482 0012 23F00403 		bic	r3, r3, #4
 483 0016 1361     		str	r3, [r2, #16]
 385:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 386:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Select SLEEP mode entry */
 387:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 484              		.loc 1 387 5
 485 0018 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
ARM GAS  /tmp/ccuGp9km.s 			page 16


 486 001a 012B     		cmp	r3, #1
 487 001c 01D1     		bne	.L29
 388:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 389:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 390:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __WFI();
 488              		.loc 1 390 5
 489              		.syntax unified
 490              	@ 390 "./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c" 1
 491 001e 30BF     		wfi
 492              	@ 0 "" 2
 391:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 392:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   else
 393:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 394:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     /* Request Wait For Event */
 395:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __WFE();
 396:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 397:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 493              		.loc 1 397 1
 494              		.thumb
 495              		.syntax unified
 496 0020 00E0     		b	.L31
 497              	.L29:
 395:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 498              		.loc 1 395 5
 499              		.syntax unified
 500              	@ 395 "./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c" 1
 501 0022 20BF     		wfe
 502              	@ 0 "" 2
 503              		.thumb
 504              		.syntax unified
 505              	.L31:
 506              		.loc 1 397 1
 507 0024 00BF     		nop
 508 0026 0C37     		adds	r7, r7, #12
 509              		.cfi_def_cfa_offset 4
 510 0028 BD46     		mov	sp, r7
 511              		.cfi_def_cfa_register 13
 512              		@ sp needed
 513 002a 5DF8047B 		ldr	r7, [sp], #4
 514              		.cfi_restore 7
 515              		.cfi_def_cfa_offset 0
 516 002e 7047     		bx	lr
 517              	.L33:
 518              		.align	2
 519              	.L32:
 520 0030 00ED00E0 		.word	-536810240
 521              		.cfi_endproc
 522              	.LFE142:
 524              		.section	.text.HAL_PWR_EnterSTOPMode,"ax",%progbits
 525              		.align	1
 526              		.global	HAL_PWR_EnterSTOPMode
 527              		.syntax unified
 528              		.thumb
 529              		.thumb_func
 530              		.fpu fpv5-d16
 532              	HAL_PWR_EnterSTOPMode:
 533              	.LFB143:
ARM GAS  /tmp/ccuGp9km.s 			page 17


 398:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 399:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 400:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Enter the system to STOP mode.
 401:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   This API must be used only for single core devices.
 402:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   In System Stop mode, all I/O pins keep the same state as in Run mode.
 403:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   When exiting System Stop mode by issuing an interrupt or a wakeup event,
 404:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         the HSI RC oscillator is selected as default system wakeup clock.
 405:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   In System STOP mode, when the voltage regulator operates in low power mode,
 406:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         an additional startup delay is incurred when the system is waking up.
 407:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption
 408:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         is higher although the startup time is reduced.
 409:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @param  Regulator: Specifies the regulator state in Stop mode.
 410:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 411:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
 412:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
 413:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @param  STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
 414:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 415:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
 416:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction
 417:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 418:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 419:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
 420:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 534              		.loc 1 420 1
 535              		.cfi_startproc
 536              		@ args = 0, pretend = 0, frame = 16
 537              		@ frame_needed = 1, uses_anonymous_args = 0
 538              		@ link register save eliminated.
 539 0000 80B4     		push	{r7}
 540              		.cfi_def_cfa_offset 4
 541              		.cfi_offset 7, -4
 542 0002 85B0     		sub	sp, sp, #20
 543              		.cfi_def_cfa_offset 24
 544 0004 00AF     		add	r7, sp, #0
 545              		.cfi_def_cfa_register 7
 546 0006 7860     		str	r0, [r7, #4]
 547 0008 0B46     		mov	r3, r1
 548 000a FB70     		strb	r3, [r7, #3]
 421:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   uint32_t tmpreg;
 422:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 423:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Check the parameters */
 424:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 425:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
 426:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 427:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Select the regulator state in Stop mode */
 428:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   tmpreg = PWR->CR1;
 549              		.loc 1 428 15
 550 000c 1D4B     		ldr	r3, .L37
 551              		.loc 1 428 10
 552 000e 1B68     		ldr	r3, [r3]
 553 0010 FB60     		str	r3, [r7, #12]
 429:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Clear PDDS and LPDS bits */
 430:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   tmpreg &= (uint32_t)~(PWR_CR1_LPDS);
 554              		.loc 1 430 10
 555 0012 FB68     		ldr	r3, [r7, #12]
 556 0014 23F00103 		bic	r3, r3, #1
 557 0018 FB60     		str	r3, [r7, #12]
ARM GAS  /tmp/ccuGp9km.s 			page 18


 431:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 432:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Set LPDS bit according to Regulator value */
 433:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   tmpreg |= Regulator;
 558              		.loc 1 433 10
 559 001a FA68     		ldr	r2, [r7, #12]
 560 001c 7B68     		ldr	r3, [r7, #4]
 561 001e 1343     		orrs	r3, r3, r2
 562 0020 FB60     		str	r3, [r7, #12]
 434:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 435:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Store the new value */
 436:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   PWR->CR1 = tmpreg;
 563              		.loc 1 436 6
 564 0022 184A     		ldr	r2, .L37
 565              		.loc 1 436 12
 566 0024 FB68     		ldr	r3, [r7, #12]
 567 0026 1360     		str	r3, [r2]
 437:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 438:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #if defined(DUAL_CORE)
 439:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Keep DSTOP mode when D1 domain enters Deepsleep */
 440:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(PWR->CPUCR, PWR_CPUCR_PDDS_D1);
 441:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(PWR->CPU2CR, PWR_CPU2CR_PDDS_D1);
 442:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #else
 443:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Keep DSTOP mode when D1 domain enters Deepsleep */
 444:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(PWR->CPUCR, PWR_CPUCR_PDDS_D1);
 568              		.loc 1 444 3
 569 0028 164B     		ldr	r3, .L37
 570 002a 1B69     		ldr	r3, [r3, #16]
 571 002c 154A     		ldr	r2, .L37
 572 002e 23F00103 		bic	r3, r3, #1
 573 0032 1361     		str	r3, [r2, #16]
 445:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 446:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Keep DSTOP mode when D2 domain enters Deepsleep */
 447:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(PWR->CPUCR, PWR_CPUCR_PDDS_D2);
 574              		.loc 1 447 3
 575 0034 134B     		ldr	r3, .L37
 576 0036 1B69     		ldr	r3, [r3, #16]
 577 0038 124A     		ldr	r2, .L37
 578 003a 23F00203 		bic	r3, r3, #2
 579 003e 1361     		str	r3, [r2, #16]
 448:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 449:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Keep DSTOP mode when D3 domain enters Deepsleep */
 450:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(PWR->CPUCR, PWR_CPUCR_PDDS_D3);
 580              		.loc 1 450 3
 581 0040 104B     		ldr	r3, .L37
 582 0042 1B69     		ldr	r3, [r3, #16]
 583 0044 0F4A     		ldr	r2, .L37
 584 0046 23F00403 		bic	r3, r3, #4
 585 004a 1361     		str	r3, [r2, #16]
 451:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #endif /*DUAL_CORE*/
 452:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 453:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 454:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 586              		.loc 1 454 12
 587 004c 0E4B     		ldr	r3, .L37+4
 588 004e 1B69     		ldr	r3, [r3, #16]
 589 0050 0D4A     		ldr	r2, .L37+4
 590 0052 43F00403 		orr	r3, r3, #4
ARM GAS  /tmp/ccuGp9km.s 			page 19


 591 0056 1361     		str	r3, [r2, #16]
 592              	.LBB6:
 593              	.LBB7:
 594              		.file 2 "./Drivers/CMSIS/Include/cmsis_gcc.h"
   1:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.1
   5:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     02. February 2017
   6:./Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:./Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:./Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:./Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:./Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:./Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:./Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:./Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:./Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:./Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:./Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:./Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  35:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  36:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                     __asm
  37:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  39:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                  inline
  40:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  41:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  42:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE           static inline
  43:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  44:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  45:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN               __attribute__((noreturn))
  46:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  47:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  48:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                    __attribute__((used))
  49:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  50:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  51:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                    __attribute__((weak))
  52:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  53:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32
ARM GAS  /tmp/ccuGp9km.s 			page 20


  54:./Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  55:./Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wpacked"
  56:./Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wattributes"
  57:./Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  58:./Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic pop
  59:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
  60:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
  62:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)              __attribute__((aligned(x)))
  63:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  65:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                  __attribute__((packed, aligned(1)))
  66:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:./Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  68:./Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT           struct __attribute__((packed, aligned(1)))
  69:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  71:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  72:./Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  73:./Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  74:./Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  75:./Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
  76:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  77:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  78:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  79:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  80:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  81:./Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  82:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  83:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
  84:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
  85:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  86:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
  87:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  88:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  89:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  90:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  91:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  92:./Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  93:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  94:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
  95:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
  96:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  97:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
  98:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
  99:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 100:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 101:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 102:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 103:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 104:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 105:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 106:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 107:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 108:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 109:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 110:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
ARM GAS  /tmp/ccuGp9km.s 			page 21


 111:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 112:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 113:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 114:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 115:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 116:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 117:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 118:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 119:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 120:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 121:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 122:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 123:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 125:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 126:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 127:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 128:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 129:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 130:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 131:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 132:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 133:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 134:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 135:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 136:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 137:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 138:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 139:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 140:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 141:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 142:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 143:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 144:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 145:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 146:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 147:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 148:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 149:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 150:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 151:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 152:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 153:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 154:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 155:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 156:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 157:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 158:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 159:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 160:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 161:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 162:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 163:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 164:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 165:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 166:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 167:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccuGp9km.s 			page 22


 168:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 169:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 170:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 171:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 172:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 173:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 174:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 175:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 176:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 178:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 179:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 180:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 182:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 183:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 184:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 185:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 186:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 187:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 188:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 189:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 190:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 191:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 192:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 193:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 194:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 195:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 196:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 197:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 198:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 199:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 200:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 201:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 202:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 203:./Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 204:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 205:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 206:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 207:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 208:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 209:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 210:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 211:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 212:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 213:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 214:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 215:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 216:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 217:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 218:./Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 219:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 220:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 221:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 222:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 223:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 224:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccuGp9km.s 			page 23


 225:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 226:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 227:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 228:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 229:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 230:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 231:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 232:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 233:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 234:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 235:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 236:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 237:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 238:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 239:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 240:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 241:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 242:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 243:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 244:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 245:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 246:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 247:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 248:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 249:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 250:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 251:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 252:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 253:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 254:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 255:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 256:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 257:./Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 258:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 259:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 260:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 261:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 262:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 263:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 264:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 265:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 266:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 267:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 268:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 269:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 270:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 271:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 272:./Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 273:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 274:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 275:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 276:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 277:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 278:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 279:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 280:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 281:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
ARM GAS  /tmp/ccuGp9km.s 			page 24


 282:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 283:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 284:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 285:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 286:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 287:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 288:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 289:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 290:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 291:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 292:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 293:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 294:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 295:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 296:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 297:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 298:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 299:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 300:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 301:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 302:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 303:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 304:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 305:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 306:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 307:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 308:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 309:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 310:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 311:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 312:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 313:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 314:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 315:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 316:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 317:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 318:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 319:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 320:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 321:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 322:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 323:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 324:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 325:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 326:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 327:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 328:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 329:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 330:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 331:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 332:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 333:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 334:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 335:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 336:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 337:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 338:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccuGp9km.s 			page 25


 339:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 340:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 341:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 342:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 343:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 344:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 345:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 346:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 347:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 348:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 349:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 350:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 351:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 352:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 353:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 354:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 355:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 356:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 357:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 358:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 359:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 360:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 361:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 362:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 363:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 364:./Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 365:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 366:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
 367:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 368:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 369:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 370:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 371:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 372:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 373:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 374:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 375:./Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 376:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 377:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
 378:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 379:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 380:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 381:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 382:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 383:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 384:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 385:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 386:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 387:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 388:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 389:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 390:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 391:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 392:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 393:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 394:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 395:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccuGp9km.s 			page 26


 396:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 397:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 398:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 399:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 400:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 401:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 402:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 403:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
 404:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 405:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 406:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 407:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 408:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 409:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 410:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 411:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 412:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 413:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 414:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 415:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 416:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 417:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 418:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 419:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 420:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 421:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 422:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 423:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 424:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 425:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 426:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 427:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 428:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 429:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 430:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 431:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 432:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 433:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 434:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 435:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 436:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 437:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 438:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 439:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 440:./Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 441:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 442:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 443:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
 444:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 445:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 446:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 447:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 448:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 449:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 450:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 451:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 452:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
ARM GAS  /tmp/ccuGp9km.s 			page 27


 453:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 454:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 455:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 456:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 457:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 458:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 459:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 460:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 461:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 462:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 463:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 464:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 465:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 466:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 467:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 468:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 469:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 470:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 471:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 472:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 473:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 474:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 475:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 476:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 477:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 478:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 479:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 480:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 481:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 482:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 483:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 484:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 485:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 486:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 487:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 488:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 489:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 490:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 491:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 492:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 493:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 494:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 495:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 496:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 497:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 498:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 499:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 500:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 501:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 502:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 503:./Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 504:./Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 505:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 506:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 507:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 508:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 509:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccuGp9km.s 			page 28


 510:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 511:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 512:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 513:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 514:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 515:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
 516:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 517:./Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 518:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 519:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 520:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 521:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 522:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 523:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 524:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 525:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 526:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 527:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 528:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 529:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 530:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 531:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
 532:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 533:./Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 534:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 535:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 536:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 537:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 538:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 539:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 540:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 541:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 542:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 543:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 544:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 545:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 546:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 547:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 548:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 549:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 550:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 551:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 552:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 553:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 554:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 555:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 556:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 557:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 558:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 559:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 560:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 561:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 562:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 563:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 564:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 565:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 566:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccuGp9km.s 			page 29


 567:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 568:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 569:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 570:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 571:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
 572:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 573:./Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 574:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 575:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 576:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 577:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 578:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 579:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 580:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 581:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 582:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 583:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 584:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 585:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 586:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 587:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 588:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
 589:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 590:./Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 591:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 592:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 593:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 594:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 595:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 596:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 597:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 598:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 599:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 600:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 601:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 602:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 603:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 604:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 605:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 606:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 607:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 608:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 609:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 610:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 611:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 612:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 613:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 614:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 615:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 616:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 617:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 618:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 619:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 620:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 621:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 622:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 623:./Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
ARM GAS  /tmp/ccuGp9km.s 			page 30


 624:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 625:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 626:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 627:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 628:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 629:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 630:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 631:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 632:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 633:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 634:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
 635:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 636:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 637:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 638:./Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 639:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 640:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 641:./Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 642:./Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 643:./Drivers/CMSIS/Include/cmsis_gcc.h ****    return(0U);
 644:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 645:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 646:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 647:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 648:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 649:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 650:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 651:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 652:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 653:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 654:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 655:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 656:./Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 657:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 658:./Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 659:./Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 660:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 661:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 662:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 663:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 664:./Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 665:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 666:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 667:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 668:./Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 669:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 670:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 671:./Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 672:./Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 673:./Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 674:./Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 675:./Drivers/CMSIS/Include/cmsis_gcc.h **** */
 676:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 677:./Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 678:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 679:./Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 680:./Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
ARM GAS  /tmp/ccuGp9km.s 			page 31


 681:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 682:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 683:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 684:./Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 685:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 686:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 687:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 688:./Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 689:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 690:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 691:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 692:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 693:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 694:./Drivers/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 695:./Drivers/CMSIS/Include/cmsis_gcc.h **** //{
 696:./Drivers/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("nop");
 697:./Drivers/CMSIS/Include/cmsis_gcc.h **** //}
 698:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")       /* This implementation gen
 699:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 700:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 701:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 702:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 703:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 704:./Drivers/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 705:./Drivers/CMSIS/Include/cmsis_gcc.h **** //{
 706:./Drivers/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("wfi");
 707:./Drivers/CMSIS/Include/cmsis_gcc.h **** //}
 708:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")       /* This implementation gen
 709:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 710:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 711:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 712:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 713:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 714:./Drivers/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 715:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 716:./Drivers/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 717:./Drivers/CMSIS/Include/cmsis_gcc.h **** //{
 718:./Drivers/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("wfe");
 719:./Drivers/CMSIS/Include/cmsis_gcc.h **** //}
 720:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")       /* This implementation gen
 721:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 722:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 723:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 724:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 725:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 726:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 727:./Drivers/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 728:./Drivers/CMSIS/Include/cmsis_gcc.h **** //{
 729:./Drivers/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("sev");
 730:./Drivers/CMSIS/Include/cmsis_gcc.h **** //}
 731:./Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")       /* This implementation gen
 732:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 733:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 734:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 735:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 736:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 737:./Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
ARM GAS  /tmp/ccuGp9km.s 			page 32


 738:./Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 739:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 740:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 741:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 742:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 743:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 744:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 745:./Drivers/CMSIS/Include/cmsis_gcc.h **** 
 746:./Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 747:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 748:./Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 749:./Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 750:./Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 751:./Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 752:./Drivers/CMSIS/Include/cmsis_gcc.h **** {
 753:./Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 595              		.loc 2 753 3
 596              		.syntax unified
 597              	@ 753 "./Drivers/CMSIS/Include/cmsis_gcc.h" 1
 598 0058 BFF34F8F 		dsb 0xF
 599              	@ 0 "" 2
 600              		.thumb
 601              		.syntax unified
 602              	.LBE7:
 603              	.LBE6:
 604              	.LBB8:
 605              	.LBB9:
 742:./Drivers/CMSIS/Include/cmsis_gcc.h **** }
 606              		.loc 2 742 3
 607              		.syntax unified
 608              	@ 742 "./Drivers/CMSIS/Include/cmsis_gcc.h" 1
 609 005c BFF36F8F 		isb 0xF
 610              	@ 0 "" 2
 611              		.thumb
 612              		.syntax unified
 613              	.LBE9:
 614              	.LBE8:
 455:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 456:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Ensure that all instructions done before entering STOP mode */
 457:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   __DSB();
 458:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   __ISB();
 459:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 460:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Select Stop mode entry */
 461:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   if(STOPEntry == PWR_STOPENTRY_WFI)
 615              		.loc 1 461 5
 616 0060 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 617 0062 012B     		cmp	r3, #1
 618 0064 01D1     		bne	.L35
 462:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 463:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 464:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __WFI();
 619              		.loc 1 464 5
 620              		.syntax unified
 621              	@ 464 "./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c" 1
 622 0066 30BF     		wfi
 623              	@ 0 "" 2
 624              		.thumb
ARM GAS  /tmp/ccuGp9km.s 			page 33


 625              		.syntax unified
 626 0068 00E0     		b	.L36
 627              	.L35:
 465:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 466:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   else
 467:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 468:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     /* Request Wait For Event */
 469:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __WFE();
 628              		.loc 1 469 5
 629              		.syntax unified
 630              	@ 469 "./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c" 1
 631 006a 20BF     		wfe
 632              	@ 0 "" 2
 633              		.thumb
 634              		.syntax unified
 635              	.L36:
 470:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 471:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 472:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
 636              		.loc 1 472 12
 637 006c 064B     		ldr	r3, .L37+4
 638 006e 1B69     		ldr	r3, [r3, #16]
 639 0070 054A     		ldr	r2, .L37+4
 640 0072 23F00403 		bic	r3, r3, #4
 641 0076 1361     		str	r3, [r2, #16]
 473:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 642              		.loc 1 473 1
 643 0078 00BF     		nop
 644 007a 1437     		adds	r7, r7, #20
 645              		.cfi_def_cfa_offset 4
 646 007c BD46     		mov	sp, r7
 647              		.cfi_def_cfa_register 13
 648              		@ sp needed
 649 007e 5DF8047B 		ldr	r7, [sp], #4
 650              		.cfi_restore 7
 651              		.cfi_def_cfa_offset 0
 652 0082 7047     		bx	lr
 653              	.L38:
 654              		.align	2
 655              	.L37:
 656 0084 00480258 		.word	1476544512
 657 0088 00ED00E0 		.word	-536810240
 658              		.cfi_endproc
 659              	.LFE143:
 661              		.section	.text.HAL_PWR_EnterSTANDBYMode,"ax",%progbits
 662              		.align	1
 663              		.global	HAL_PWR_EnterSTANDBYMode
 664              		.syntax unified
 665              		.thumb
 666              		.thumb_func
 667              		.fpu fpv5-d16
 669              	HAL_PWR_EnterSTANDBYMode:
 670              	.LFB144:
 474:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 475:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 476:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Enter the system to STANDBY mode.
 477:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   The system enters Standby mode only when the D1, D2 and D3 domains are in DStandby.
ARM GAS  /tmp/ccuGp9km.s 			page 34


 478:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   When the System exit STANDBY mode by issuing an interrupt or a wakeup event,
 479:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 480:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None.
 481:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 482:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_EnterSTANDBYMode(void)
 483:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 671              		.loc 1 483 1
 672              		.cfi_startproc
 673              		@ args = 0, pretend = 0, frame = 0
 674              		@ frame_needed = 1, uses_anonymous_args = 0
 675              		@ link register save eliminated.
 676 0000 80B4     		push	{r7}
 677              		.cfi_def_cfa_offset 4
 678              		.cfi_offset 7, -4
 679 0002 00AF     		add	r7, sp, #0
 680              		.cfi_def_cfa_register 7
 484:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #if defined(DUAL_CORE)
 485:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Keep DSTANDBY mode when D1 domain enters Deepsleep */
 486:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(PWR->CPUCR, PWR_CPUCR_PDDS_D1);
 487:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(PWR->CPU2CR, PWR_CPU2CR_PDDS_D1);
 488:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #else
 489:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Keep DSTANDBY mode when D1 domain enters Deepsleep */
 490:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(PWR->CPUCR, PWR_CPUCR_PDDS_D1);
 681              		.loc 1 490 3
 682 0004 0E4B     		ldr	r3, .L40
 683 0006 1B69     		ldr	r3, [r3, #16]
 684 0008 0D4A     		ldr	r2, .L40
 685 000a 43F00103 		orr	r3, r3, #1
 686 000e 1361     		str	r3, [r2, #16]
 491:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 492:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Keep DSTANDBY mode when D2 domain enters Deepsleep */
 493:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(PWR->CPUCR, PWR_CPUCR_PDDS_D2);
 687              		.loc 1 493 3
 688 0010 0B4B     		ldr	r3, .L40
 689 0012 1B69     		ldr	r3, [r3, #16]
 690 0014 0A4A     		ldr	r2, .L40
 691 0016 43F00203 		orr	r3, r3, #2
 692 001a 1361     		str	r3, [r2, #16]
 494:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 495:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Keep DSTANDBY mode when D3 domain enters Deepsleep */
 496:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(PWR->CPUCR, PWR_CPUCR_PDDS_D3);
 693              		.loc 1 496 3
 694 001c 084B     		ldr	r3, .L40
 695 001e 1B69     		ldr	r3, [r3, #16]
 696 0020 074A     		ldr	r2, .L40
 697 0022 43F00403 		orr	r3, r3, #4
 698 0026 1361     		str	r3, [r2, #16]
 497:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #endif /*DUAL_CORE*/
 498:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 499:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 500:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 699              		.loc 1 500 12
 700 0028 064B     		ldr	r3, .L40+4
 701 002a 1B69     		ldr	r3, [r3, #16]
 702 002c 054A     		ldr	r2, .L40+4
 703 002e 43F00403 		orr	r3, r3, #4
 704 0032 1361     		str	r3, [r2, #16]
ARM GAS  /tmp/ccuGp9km.s 			page 35


 501:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 502:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* This option is used to ensure that store operations are completed */
 503:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #if defined ( __CC_ARM)
 504:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   __force_stores();
 505:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #endif
 506:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Request Wait For Interrupt */
 507:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   __WFI();
 705              		.loc 1 507 3
 706              		.syntax unified
 707              	@ 507 "./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c" 1
 708 0034 30BF     		wfi
 709              	@ 0 "" 2
 508:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 710              		.loc 1 508 1
 711              		.thumb
 712              		.syntax unified
 713 0036 00BF     		nop
 714 0038 BD46     		mov	sp, r7
 715              		.cfi_def_cfa_register 13
 716              		@ sp needed
 717 003a 5DF8047B 		ldr	r7, [sp], #4
 718              		.cfi_restore 7
 719              		.cfi_def_cfa_offset 0
 720 003e 7047     		bx	lr
 721              	.L41:
 722              		.align	2
 723              	.L40:
 724 0040 00480258 		.word	1476544512
 725 0044 00ED00E0 		.word	-536810240
 726              		.cfi_endproc
 727              	.LFE144:
 729              		.section	.text.HAL_PWR_EnableSleepOnExit,"ax",%progbits
 730              		.align	1
 731              		.global	HAL_PWR_EnableSleepOnExit
 732              		.syntax unified
 733              		.thumb
 734              		.thumb_func
 735              		.fpu fpv5-d16
 737              	HAL_PWR_EnableSleepOnExit:
 738              	.LFB145:
 509:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 510:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 511:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Indicate Sleep-On-Exit when returning from Handler mode to Thread mode.
 512:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor
 513:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         re-enters SLEEP mode when an interruption handling is over.
 514:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         Setting this bit is useful when the processor is expected to run only on
 515:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         interruptions handling.
 516:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 517:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 518:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_EnableSleepOnExit(void)
 519:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 739              		.loc 1 519 1
 740              		.cfi_startproc
 741              		@ args = 0, pretend = 0, frame = 0
 742              		@ frame_needed = 1, uses_anonymous_args = 0
 743              		@ link register save eliminated.
 744 0000 80B4     		push	{r7}
ARM GAS  /tmp/ccuGp9km.s 			page 36


 745              		.cfi_def_cfa_offset 4
 746              		.cfi_offset 7, -4
 747 0002 00AF     		add	r7, sp, #0
 748              		.cfi_def_cfa_register 7
 520:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Set SLEEPONEXIT bit of Cortex System Control Register */
 521:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 749              		.loc 1 521 3
 750 0004 054B     		ldr	r3, .L43
 751 0006 1B69     		ldr	r3, [r3, #16]
 752 0008 044A     		ldr	r2, .L43
 753 000a 43F00203 		orr	r3, r3, #2
 754 000e 1361     		str	r3, [r2, #16]
 522:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 755              		.loc 1 522 1
 756 0010 00BF     		nop
 757 0012 BD46     		mov	sp, r7
 758              		.cfi_def_cfa_register 13
 759              		@ sp needed
 760 0014 5DF8047B 		ldr	r7, [sp], #4
 761              		.cfi_restore 7
 762              		.cfi_def_cfa_offset 0
 763 0018 7047     		bx	lr
 764              	.L44:
 765 001a 00BF     		.align	2
 766              	.L43:
 767 001c 00ED00E0 		.word	-536810240
 768              		.cfi_endproc
 769              	.LFE145:
 771              		.section	.text.HAL_PWR_DisableSleepOnExit,"ax",%progbits
 772              		.align	1
 773              		.global	HAL_PWR_DisableSleepOnExit
 774              		.syntax unified
 775              		.thumb
 776              		.thumb_func
 777              		.fpu fpv5-d16
 779              	HAL_PWR_DisableSleepOnExit:
 780              	.LFB146:
 523:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 524:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 525:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 526:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Disable Sleep-On-Exit feature when returning from Handler mode to Thread mode.
 527:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor
 528:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         re-enters SLEEP mode when an interruption handling is over.
 529:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 530:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 531:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_DisableSleepOnExit(void)
 532:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 781              		.loc 1 532 1
 782              		.cfi_startproc
 783              		@ args = 0, pretend = 0, frame = 0
 784              		@ frame_needed = 1, uses_anonymous_args = 0
 785              		@ link register save eliminated.
 786 0000 80B4     		push	{r7}
 787              		.cfi_def_cfa_offset 4
 788              		.cfi_offset 7, -4
 789 0002 00AF     		add	r7, sp, #0
 790              		.cfi_def_cfa_register 7
ARM GAS  /tmp/ccuGp9km.s 			page 37


 533:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
 534:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 791              		.loc 1 534 3
 792 0004 054B     		ldr	r3, .L46
 793 0006 1B69     		ldr	r3, [r3, #16]
 794 0008 044A     		ldr	r2, .L46
 795 000a 23F00203 		bic	r3, r3, #2
 796 000e 1361     		str	r3, [r2, #16]
 535:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 797              		.loc 1 535 1
 798 0010 00BF     		nop
 799 0012 BD46     		mov	sp, r7
 800              		.cfi_def_cfa_register 13
 801              		@ sp needed
 802 0014 5DF8047B 		ldr	r7, [sp], #4
 803              		.cfi_restore 7
 804              		.cfi_def_cfa_offset 0
 805 0018 7047     		bx	lr
 806              	.L47:
 807 001a 00BF     		.align	2
 808              	.L46:
 809 001c 00ED00E0 		.word	-536810240
 810              		.cfi_endproc
 811              	.LFE146:
 813              		.section	.text.HAL_PWR_EnableSEVOnPend,"ax",%progbits
 814              		.align	1
 815              		.global	HAL_PWR_EnableSEVOnPend
 816              		.syntax unified
 817              		.thumb
 818              		.thumb_func
 819              		.fpu fpv5-d16
 821              	HAL_PWR_EnableSEVOnPend:
 822              	.LFB147:
 536:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 537:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 538:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Enable CORTEX SEVONPEND bit.
 539:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   Sets SEVONPEND bit of SCR register. When this bit is set, this causes
 540:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         WFE to wake up when an interrupt moves from inactive to pended.
 541:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 542:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 543:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_EnableSEVOnPend(void)
 544:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 823              		.loc 1 544 1
 824              		.cfi_startproc
 825              		@ args = 0, pretend = 0, frame = 0
 826              		@ frame_needed = 1, uses_anonymous_args = 0
 827              		@ link register save eliminated.
 828 0000 80B4     		push	{r7}
 829              		.cfi_def_cfa_offset 4
 830              		.cfi_offset 7, -4
 831 0002 00AF     		add	r7, sp, #0
 832              		.cfi_def_cfa_register 7
 545:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Set SEVONPEND bit of Cortex System Control Register */
 546:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 833              		.loc 1 546 3
 834 0004 054B     		ldr	r3, .L49
 835 0006 1B69     		ldr	r3, [r3, #16]
ARM GAS  /tmp/ccuGp9km.s 			page 38


 836 0008 044A     		ldr	r2, .L49
 837 000a 43F01003 		orr	r3, r3, #16
 838 000e 1361     		str	r3, [r2, #16]
 547:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 839              		.loc 1 547 1
 840 0010 00BF     		nop
 841 0012 BD46     		mov	sp, r7
 842              		.cfi_def_cfa_register 13
 843              		@ sp needed
 844 0014 5DF8047B 		ldr	r7, [sp], #4
 845              		.cfi_restore 7
 846              		.cfi_def_cfa_offset 0
 847 0018 7047     		bx	lr
 848              	.L50:
 849 001a 00BF     		.align	2
 850              	.L49:
 851 001c 00ED00E0 		.word	-536810240
 852              		.cfi_endproc
 853              	.LFE147:
 855              		.section	.text.HAL_PWR_DisableSEVOnPend,"ax",%progbits
 856              		.align	1
 857              		.global	HAL_PWR_DisableSEVOnPend
 858              		.syntax unified
 859              		.thumb
 860              		.thumb_func
 861              		.fpu fpv5-d16
 863              	HAL_PWR_DisableSEVOnPend:
 864              	.LFB148:
 548:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 549:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 550:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  Disable CORTEX SEVONPEND bit.
 551:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   Clears SEVONPEND bit of SCR register. When this bit is set, this causes
 552:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   *         WFE to wake up when an interrupt moves from inactive to pended.
 553:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 554:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 555:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_DisableSEVOnPend(void)
 556:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 865              		.loc 1 556 1
 866              		.cfi_startproc
 867              		@ args = 0, pretend = 0, frame = 0
 868              		@ frame_needed = 1, uses_anonymous_args = 0
 869              		@ link register save eliminated.
 870 0000 80B4     		push	{r7}
 871              		.cfi_def_cfa_offset 4
 872              		.cfi_offset 7, -4
 873 0002 00AF     		add	r7, sp, #0
 874              		.cfi_def_cfa_register 7
 557:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* Clear SEVONPEND bit of Cortex System Control Register */
 558:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 875              		.loc 1 558 3
 876 0004 054B     		ldr	r3, .L52
 877 0006 1B69     		ldr	r3, [r3, #16]
 878 0008 044A     		ldr	r2, .L52
 879 000a 23F01003 		bic	r3, r3, #16
 880 000e 1361     		str	r3, [r2, #16]
 559:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 881              		.loc 1 559 1
ARM GAS  /tmp/ccuGp9km.s 			page 39


 882 0010 00BF     		nop
 883 0012 BD46     		mov	sp, r7
 884              		.cfi_def_cfa_register 13
 885              		@ sp needed
 886 0014 5DF8047B 		ldr	r7, [sp], #4
 887              		.cfi_restore 7
 888              		.cfi_def_cfa_offset 0
 889 0018 7047     		bx	lr
 890              	.L53:
 891 001a 00BF     		.align	2
 892              	.L52:
 893 001c 00ED00E0 		.word	-536810240
 894              		.cfi_endproc
 895              	.LFE148:
 897              		.section	.text.HAL_PWR_PVD_IRQHandler,"ax",%progbits
 898              		.align	1
 899              		.global	HAL_PWR_PVD_IRQHandler
 900              		.syntax unified
 901              		.thumb
 902              		.thumb_func
 903              		.fpu fpv5-d16
 905              	HAL_PWR_PVD_IRQHandler:
 906              	.LFB149:
 560:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 561:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 562:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  This function handles the PWR PVD interrupt request.
 563:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @note   This API should be called under the PVD_IRQHandler().
 564:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 565:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 566:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** void HAL_PWR_PVD_IRQHandler(void)
 567:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 907              		.loc 1 567 1
 908              		.cfi_startproc
 909              		@ args = 0, pretend = 0, frame = 0
 910              		@ frame_needed = 1, uses_anonymous_args = 0
 911 0000 80B5     		push	{r7, lr}
 912              		.cfi_def_cfa_offset 8
 913              		.cfi_offset 7, -8
 914              		.cfi_offset 14, -4
 915 0002 00AF     		add	r7, sp, #0
 916              		.cfi_def_cfa_register 7
 568:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #if defined(DUAL_CORE)
 569:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* PVD EXTI line interrupt detected */
 570:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   if (HAL_GetCurrentCPUID() == CM7_CPUID)
 571:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 572:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     /* Check PWR EXTI flag */
 573:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 574:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     {
 575:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       /* PWR PVD interrupt user callback */
 576:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       HAL_PWR_PVDCallback();
 577:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 578:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       /* Clear PWR EXTI pending bit */
 579:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 580:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     }
 581:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 582:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   else
 583:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
ARM GAS  /tmp/ccuGp9km.s 			page 40


 584:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     /* Check PWR EXTI D2 flag */
 585:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     if(__HAL_PWR_PVD_EXTID2_GET_FLAG() != RESET)
 586:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     {
 587:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       /* PWR PVD interrupt user callback */
 588:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       HAL_PWR_PVDCallback();
 589:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 590:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       /* Clear PWR EXTI D2 pending bit */
 591:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****       __HAL_PWR_PVD_EXTID2_CLEAR_FLAG();
 592:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     }
 593:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 594:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #else
 595:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* PVD EXTI line interrupt detected */
 596:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 917              		.loc 1 596 6
 918 0004 4FF0B043 		mov	r3, #1476395008
 919 0008 D3F88830 		ldr	r3, [r3, #136]
 920 000c 03F48033 		and	r3, r3, #65536
 921              		.loc 1 596 5
 922 0010 B3F5803F 		cmp	r3, #65536
 923 0014 0BD1     		bne	.L56
 597:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   {
 598:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     /* PWR PVD interrupt user callback */
 599:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     HAL_PWR_PVDCallback();
 924              		.loc 1 599 5
 925 0016 FFF7FEFF 		bl	HAL_PWR_PVDCallback
 600:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 601:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     /* Clear PWR EXTI pending bit */
 602:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 926              		.loc 1 602 5
 927 001a 4FF0B043 		mov	r3, #1476395008
 928 001e D3F88830 		ldr	r3, [r3, #136]
 929 0022 4FF0B042 		mov	r2, #1476395008
 930 0026 43F48033 		orr	r3, r3, #65536
 931 002a C2F88830 		str	r3, [r2, #136]
 932              	.L56:
 603:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   }
 604:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** #endif /*DUAL_CORE*/
 605:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 933              		.loc 1 605 1
 934 002e 00BF     		nop
 935 0030 80BD     		pop	{r7, pc}
 936              		.cfi_endproc
 937              	.LFE149:
 939              		.section	.text.HAL_PWR_PVDCallback,"ax",%progbits
 940              		.align	1
 941              		.weak	HAL_PWR_PVDCallback
 942              		.syntax unified
 943              		.thumb
 944              		.thumb_func
 945              		.fpu fpv5-d16
 947              	HAL_PWR_PVDCallback:
 948              	.LFB150:
 606:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** 
 607:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** /**
 608:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @brief  PWR PVD interrupt callback
 609:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   * @retval None
 610:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
ARM GAS  /tmp/ccuGp9km.s 			page 41


 611:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** __weak void HAL_PWR_PVDCallback(void)
 612:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** {
 949              		.loc 1 612 1
 950              		.cfi_startproc
 951              		@ args = 0, pretend = 0, frame = 0
 952              		@ frame_needed = 1, uses_anonymous_args = 0
 953              		@ link register save eliminated.
 954 0000 80B4     		push	{r7}
 955              		.cfi_def_cfa_offset 4
 956              		.cfi_offset 7, -4
 957 0002 00AF     		add	r7, sp, #0
 958              		.cfi_def_cfa_register 7
 613:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   /* NOTE : This function Should not be modified, when the callback is needed,
 614:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****             the HAL_PWR_PVDCallback could be implemented in the user file
 615:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c ****   */
 616:./Drivers/STM32H7xx_HAL_Driver/Src/stm32h7xx_hal_pwr.c **** }
 959              		.loc 1 616 1
 960 0004 00BF     		nop
 961 0006 BD46     		mov	sp, r7
 962              		.cfi_def_cfa_register 13
 963              		@ sp needed
 964 0008 5DF8047B 		ldr	r7, [sp], #4
 965              		.cfi_restore 7
 966              		.cfi_def_cfa_offset 0
 967 000c 7047     		bx	lr
 968              		.cfi_endproc
 969              	.LFE150:
 971              		.text
 972              	.Letext0:
 973              		.file 3 "/mnt/d/GNU Tools ARM Embedded/gcc-arm-none-eabi-8-2019-q3-update/arm-none-eabi/include/ma
 974              		.file 4 "/mnt/d/GNU Tools ARM Embedded/gcc-arm-none-eabi-8-2019-q3-update/arm-none-eabi/include/sy
 975              		.file 5 "./Drivers/CMSIS/Include/core_cm7.h"
 976              		.file 6 "./Drivers/CMSIS/Device/ST/STM32H7xx/Include/system_stm32h7xx.h"
 977              		.file 7 "./Drivers/CMSIS/Device/ST/STM32H7xx/Include/stm32h743xx.h"
 978              		.file 8 "/mnt/d/GNU Tools ARM Embedded/gcc-arm-none-eabi-8-2019-q3-update/lib/gcc/arm-none-eabi/8.
 979              		.file 9 "/mnt/d/GNU Tools ARM Embedded/gcc-arm-none-eabi-8-2019-q3-update/arm-none-eabi/include/sy
 980              		.file 10 "/mnt/d/GNU Tools ARM Embedded/gcc-arm-none-eabi-8-2019-q3-update/arm-none-eabi/include/s
 981              		.file 11 "/mnt/d/GNU Tools ARM Embedded/gcc-arm-none-eabi-8-2019-q3-update/arm-none-eabi/include/s
 982              		.file 12 "/mnt/d/GNU Tools ARM Embedded/gcc-arm-none-eabi-8-2019-q3-update/arm-none-eabi/include/m
 983              		.file 13 "./Drivers/CMSIS/Device/ST/STM32H7xx/Include/stm32h7xx.h"
 984              		.file 14 "./Drivers/STM32H7xx_HAL_Driver/Inc/stm32h7xx_hal_def.h"
 985              		.file 15 "./Drivers/STM32H7xx_HAL_Driver/Inc/stm32h7xx_hal_flash.h"
 986              		.file 16 "./Drivers/STM32H7xx_HAL_Driver/Inc/stm32h7xx_hal_pwr.h"
ARM GAS  /tmp/ccuGp9km.s 			page 42


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32h7xx_hal_pwr.c
     /tmp/ccuGp9km.s:17     .text.HAL_PWR_DeInit:0000000000000000 $t
     /tmp/ccuGp9km.s:25     .text.HAL_PWR_DeInit:0000000000000000 HAL_PWR_DeInit
     /tmp/ccuGp9km.s:51     .text.HAL_PWR_EnableBkUpAccess:0000000000000000 $t
     /tmp/ccuGp9km.s:58     .text.HAL_PWR_EnableBkUpAccess:0000000000000000 HAL_PWR_EnableBkUpAccess
     /tmp/ccuGp9km.s:88     .text.HAL_PWR_EnableBkUpAccess:000000000000001c $d
     /tmp/ccuGp9km.s:93     .text.HAL_PWR_DisableBkUpAccess:0000000000000000 $t
     /tmp/ccuGp9km.s:100    .text.HAL_PWR_DisableBkUpAccess:0000000000000000 HAL_PWR_DisableBkUpAccess
     /tmp/ccuGp9km.s:130    .text.HAL_PWR_DisableBkUpAccess:000000000000001c $d
     /tmp/ccuGp9km.s:135    .text.HAL_PWR_ConfigPVD:0000000000000000 $t
     /tmp/ccuGp9km.s:142    .text.HAL_PWR_ConfigPVD:0000000000000000 HAL_PWR_ConfigPVD
     /tmp/ccuGp9km.s:264    .text.HAL_PWR_ConfigPVD:00000000000000e8 $d
     /tmp/ccuGp9km.s:269    .text.HAL_PWR_EnablePVD:0000000000000000 $t
     /tmp/ccuGp9km.s:276    .text.HAL_PWR_EnablePVD:0000000000000000 HAL_PWR_EnablePVD
     /tmp/ccuGp9km.s:306    .text.HAL_PWR_EnablePVD:000000000000001c $d
     /tmp/ccuGp9km.s:311    .text.HAL_PWR_DisablePVD:0000000000000000 $t
     /tmp/ccuGp9km.s:318    .text.HAL_PWR_DisablePVD:0000000000000000 HAL_PWR_DisablePVD
     /tmp/ccuGp9km.s:348    .text.HAL_PWR_DisablePVD:000000000000001c $d
     /tmp/ccuGp9km.s:353    .text.HAL_PWR_EnableWakeUpPin:0000000000000000 $t
     /tmp/ccuGp9km.s:360    .text.HAL_PWR_EnableWakeUpPin:0000000000000000 HAL_PWR_EnableWakeUpPin
     /tmp/ccuGp9km.s:398    .text.HAL_PWR_EnableWakeUpPin:0000000000000024 $d
     /tmp/ccuGp9km.s:404    .text.HAL_PWR_DisableWakeUpPin:0000000000000000 $t
     /tmp/ccuGp9km.s:411    .text.HAL_PWR_DisableWakeUpPin:0000000000000000 HAL_PWR_DisableWakeUpPin
     /tmp/ccuGp9km.s:449    .text.HAL_PWR_DisableWakeUpPin:0000000000000028 $d
     /tmp/ccuGp9km.s:454    .text.HAL_PWR_EnterSLEEPMode:0000000000000000 $t
     /tmp/ccuGp9km.s:461    .text.HAL_PWR_EnterSLEEPMode:0000000000000000 HAL_PWR_EnterSLEEPMode
     /tmp/ccuGp9km.s:520    .text.HAL_PWR_EnterSLEEPMode:0000000000000030 $d
     /tmp/ccuGp9km.s:525    .text.HAL_PWR_EnterSTOPMode:0000000000000000 $t
     /tmp/ccuGp9km.s:532    .text.HAL_PWR_EnterSTOPMode:0000000000000000 HAL_PWR_EnterSTOPMode
     /tmp/ccuGp9km.s:656    .text.HAL_PWR_EnterSTOPMode:0000000000000084 $d
     /tmp/ccuGp9km.s:662    .text.HAL_PWR_EnterSTANDBYMode:0000000000000000 $t
     /tmp/ccuGp9km.s:669    .text.HAL_PWR_EnterSTANDBYMode:0000000000000000 HAL_PWR_EnterSTANDBYMode
     /tmp/ccuGp9km.s:724    .text.HAL_PWR_EnterSTANDBYMode:0000000000000040 $d
     /tmp/ccuGp9km.s:730    .text.HAL_PWR_EnableSleepOnExit:0000000000000000 $t
     /tmp/ccuGp9km.s:737    .text.HAL_PWR_EnableSleepOnExit:0000000000000000 HAL_PWR_EnableSleepOnExit
     /tmp/ccuGp9km.s:767    .text.HAL_PWR_EnableSleepOnExit:000000000000001c $d
     /tmp/ccuGp9km.s:772    .text.HAL_PWR_DisableSleepOnExit:0000000000000000 $t
     /tmp/ccuGp9km.s:779    .text.HAL_PWR_DisableSleepOnExit:0000000000000000 HAL_PWR_DisableSleepOnExit
     /tmp/ccuGp9km.s:809    .text.HAL_PWR_DisableSleepOnExit:000000000000001c $d
     /tmp/ccuGp9km.s:814    .text.HAL_PWR_EnableSEVOnPend:0000000000000000 $t
     /tmp/ccuGp9km.s:821    .text.HAL_PWR_EnableSEVOnPend:0000000000000000 HAL_PWR_EnableSEVOnPend
     /tmp/ccuGp9km.s:851    .text.HAL_PWR_EnableSEVOnPend:000000000000001c $d
     /tmp/ccuGp9km.s:856    .text.HAL_PWR_DisableSEVOnPend:0000000000000000 $t
     /tmp/ccuGp9km.s:863    .text.HAL_PWR_DisableSEVOnPend:0000000000000000 HAL_PWR_DisableSEVOnPend
     /tmp/ccuGp9km.s:893    .text.HAL_PWR_DisableSEVOnPend:000000000000001c $d
     /tmp/ccuGp9km.s:898    .text.HAL_PWR_PVD_IRQHandler:0000000000000000 $t
     /tmp/ccuGp9km.s:905    .text.HAL_PWR_PVD_IRQHandler:0000000000000000 HAL_PWR_PVD_IRQHandler
     /tmp/ccuGp9km.s:947    .text.HAL_PWR_PVDCallback:0000000000000000 HAL_PWR_PVDCallback
     /tmp/ccuGp9km.s:940    .text.HAL_PWR_PVDCallback:0000000000000000 $t

NO UNDEFINED SYMBOLS
